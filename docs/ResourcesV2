Objectif :
Migrer le syst√®me de gestion des ressources depuis un mod√®le unique (Foodstock) vers un syst√®me g√©n√©rique multi-ressources.
Le but est de permettre √† la fois la gestion des vivres, bois, minerai, m√©tal, tissu, planches, etc., dans les villes et exp√©ditions.

‚öôÔ∏è √âtapes de d√©veloppement

Cr√©er un fichier docs/resources-todo.md

## Migration multi-ressources (V1)
- [ ] Cr√©er les mod√®les Prisma ResourceType et ResourceStock
- [ ] Ajouter un script de seed pour les types de ressources
- [ ] Migrer les donn√©es depuis Foodstock ‚Üí ResourceStock
- [ ] Remplacer la commande /foodstock par /stock
- [ ] Adapter la logique de capacit√© (r√©colte) vers ResourceStock
- [ ] Adapter les exp√©ditions (stock s√©par√©)
- [ ] Supprimer Foodstock une fois la migration valid√©e


Cr√©er les mod√®les Prisma
Dans prisma/schema.prisma :

model ResourceType {
  id          Int          @id @default(autoincrement())
  name        String
  emoji       String
  category    String
  description String?
  stocks      ResourceStock[]
}

model ResourceStock {
  id              Int           @id @default(autoincrement())
  locationType    String        // 'CITY' | 'EXPEDITION'
  locationId      Int
  resourceTypeId  Int
  quantity        Int           @default(0)
  resourceType    ResourceType  @relation(fields: [resourceTypeId], references: [id])
}


Cr√©er le seed initial
Dans prisma/seed.ts (ou √©quivalent) :

await prisma.resourceType.createMany({
  data: [
    { name: "Vivres", emoji: "üçû", category: "base", description: "Ressource brute de survie" },
    { name: "Bois", emoji: "üå≤", category: "base", description: "Mat√©riau brut" },
    { name: "Minerai", emoji: "‚õèÔ∏è", category: "base", description: "Mat√©riau brut" },
    { name: "M√©tal", emoji: "‚öôÔ∏è", category: "transform√©", description: "Produit du minerai" },
    { name: "Tissu", emoji: "üßµ", category: "transform√©", description: "Produit du bois" },
    { name: "Planches", emoji: "ü™µ", category: "transform√©", description: "Produit du bois" },
    { name: "Nourriture", emoji: "üçñ", category: "transform√©", description: "Produit des vivres" },
  ],
  skipDuplicates: true,
});


Migration des donn√©es

Cr√©er un script temporaire dans /scripts/migrateFoodstockToResource.ts

const vivresType = await prisma.resourceType.findFirst({ where: { name: "Vivres" } });
const cities = await prisma.city.findMany({ include: { foodstock: true } });

for (const city of cities) {
  await prisma.resourceStock.create({
    data: {
      locationType: "CITY",
      locationId: city.id,
      resourceTypeId: vivresType.id,
      quantity: city.foodstock.quantity,
    },
  });
}


Une fois v√©rifi√©, supprimer la table Foodstock.

Remplacer /foodstock par /stock

Nouvelle commande /stock :

/stock
Affiche les ressources de la ville :
üèôÔ∏è Stock de la ville :
üçû Vivres : 340
üå≤ Bois : 120
‚õèÔ∏è Minerai : 50


Utiliser ResourceStock pour r√©cup√©rer les ressources associ√©es √† la ville (locationType = CITY et locationId = cityId).

Adapter les capacit√©s

Les capacit√©s de r√©colte (chasser, cueillir, etc.) doivent d√©sormais :

R√©cup√©rer l‚ÄôID de la ressource ‚ÄúVivres‚Äù

Ajouter le r√©sultat de la r√©colte dans ResourceStock (et non plus Foodstock)

Exemple :

const vivres = await prisma.resourceType.findFirst({ where: { name: "Vivres" } });
await prisma.resourceStock.upsert({
  where: { locationType_locationId_resourceTypeId: { locationType: "CITY", locationId: city.id, resourceTypeId: vivres.id } },
  update: { quantity: { increment: gained } },
  create: { locationType: "CITY", locationId: city.id, resourceTypeId: vivres.id, quantity: gained },
});


Adapter les exp√©ditions

Chaque exp√©dition aura son propre ensemble de ResourceStock (m√™me logique que pour les villes).

Les commandes /expedition stock doivent afficher les ressources de cette exp√©dition.

Tests et v√©rifications

V√©rifier que /stock fonctionne correctement pour toutes les villes.

V√©rifier la compatibilit√© avec les exp√©ditions.

V√©rifier que les capacit√©s de r√©colte ajoutent bien les ressources dans la bonne entit√©.

Nettoyer le code en supprimant Foodstock apr√®s validation.

‚úÖ Crit√®res de succ√®s

/stock fonctionne et remplace /foodstock

Toutes les ressources sont g√©r√©es via ResourceStock

Les capacit√©s de r√©colte utilisent bien la nouvelle structure

L‚Äôancienne table Foodstock est retir√©e proprement

Le code reste backward-compatible pour les migrations en cours