import {
  createInfoEmbed,
  createSuccessEmbed,
  createWarningEmbed,
} from "../../utils/embeds";
import {
  EmbedBuilder,
  ActionRowBuilder,
  StringSelectMenuBuilder,
  ComponentType,
  type CommandInteraction,
  type StringSelectMenuInteraction,
  type ChatInputCommandInteraction,
  Client,
  PermissionFlagsBits,
} from "discord.js";
import { apiService } from "../../services/api";
import {
  replyEphemeral,
  replyError,
  replySuccess,
} from "../../utils/interaction-helpers.js";
import { logger } from "../../services/logger.js";

interface GuildConfig {
  id: string;
  discordGuildId: string;
  name: string;
  logChannelId?: string | null;
  [key: string]: any; // Pour les autres propri√©t√©s qui pourraient exister
}

export async function handleConfigChannelCommand(
  interaction: ChatInputCommandInteraction
) {
  if (!interaction.guild) {
    return replyEphemeral(
      interaction,
      "Cette commande ne peut √™tre utilis√©e que dans un serveur."
    );
  }

  // V√©rifier les permissions d'administrateur
  if (!interaction.memberPermissions?.has(PermissionFlagsBits.Administrator)) {
    return replyEphemeral(
      interaction,
      "Vous devez √™tre administrateur pour utiliser cette commande."
    );
  }

  const guild = interaction.guild;

  // S'assurer que la guilde existe avant de continuer
  try {
    // Cr√©er la guilde si elle n'existe pas
    await apiService.guilds.getOrCreateGuild(
      guild.id,
      guild.name,
      guild.memberCount
    );
  } catch (error) {
    logger.error("Failed to get or create guild:", { error });
    return replyEphemeral(
      interaction,
      "Une erreur est survenue lors de la configuration de la guilde."
    );
  }

  // R√©cup√©rer la configuration de la guilde
  let currentLogChannel = null;
  let currentLogChannelName = null;
  try {
    const guildConfig = (await apiService.guilds.getGuildByDiscordId(
      guild.id
    )) as GuildConfig;
    
    if (guildConfig?.logChannelId) {
      currentLogChannel = guild.channels.cache.get(guildConfig.logChannelId);
      currentLogChannelName = currentLogChannel
        ? currentLogChannel.name
        : "Salon supprim√©";
    }
  } catch (error) {
    logger.warn("Could not fetch current guild configuration:", { error });
  }

  const textChannels = guild.channels.cache.filter(
    (channel) =>
      channel.type === 0 && // TextChannel
      channel
        .permissionsFor(interaction.user)
        ?.has(PermissionFlagsBits.SendMessages)
  );

  if (textChannels.size === 0) {
    return replyEphemeral(
      interaction,
      "Aucun salon textuel accessible n'a √©t√© trouv√©."
    );
  }

  // Limiter √† 25 salons maximum (limite Discord)
  const channelsToShow = textChannels.first(25);

  // Construire les options du menu d√©roulant
  const menuOptions = channelsToShow.map((channel) => ({
    label: channel.name,
    description:
      channel.id === currentLogChannel?.id
        ? `Salon actuel: #${channel.name}`
        : `Salon: #${channel.name}`,
    value: channel.id,
    emoji: channel.id === currentLogChannel?.id ? "‚úÖ" : undefined,
  }));

  // Ajouter une option pour d√©sactiver les logs si un salon est configur√©
  if (currentLogChannel) {
    menuOptions.push({
      label: "Aucun salon (d√©sactiver les logs)",
      description: "D√©sactiver l'envoi automatique des logs",
      value: "none",
      emoji: "üö´",
    });
  }

  const selectMenu = new StringSelectMenuBuilder()
    .setCustomId("config_channel_select")
    .setPlaceholder("Choisissez un salon pour les logs")
    .addOptions(menuOptions);

  // Construire la description de l'embed
  let embedDescription =
    "Choisissez le salon dans lequel les logs automatiques seront envoy√©s.\n\n";
  embedDescription += "Les logs incluent :\n";
  embedDescription += "‚Ä¢ Les investissements dans les chantiers\n";
  embedDescription += "‚Ä¢ Les actions des personnages\n";
  embedDescription += "‚Ä¢ Autres √©v√©nements automatiques\n\n";

  if (currentLogChannel) {
    embedDescription += `**Salon actuel :** ${currentLogChannel} (ID: ${currentLogChannel.id})\n`;
    embedDescription +=
      "üí° S√©lectionnez un autre salon pour le changer, ou choisissez 'Aucun salon' pour d√©sactiver les logs.";
  } else {
    embedDescription +=
      "‚ÑπÔ∏è Aucun salon n'est actuellement configur√© pour les logs.";
  }

  const embed = createInfoEmbed(
    "‚öôÔ∏è Configuration du salon de logs",
    embedDescription
  );

  const row = new ActionRowBuilder<StringSelectMenuBuilder>().addComponents(
    selectMenu
  );

  const response = await interaction.reply({
    embeds: [embed],
    components: [row],
    flags: ["Ephemeral"],
  });

  try {
    const selectInteraction = (await response.awaitMessageComponent({
      componentType: ComponentType.StringSelect,
      time: 60000, // 1 minute
    })) as StringSelectMenuInteraction;

    const selectedChannelId = selectInteraction.values[0];

    if (selectedChannelId === "none") {
      // D√©sactiver les logs
      await apiService.updateGuildLogChannel(guild.id, null);

      logger.info(`Log channel disabled for guild ${guild.id}`);

      const successEmbed = createWarningEmbed(
        "üö´ Logs d√©sactiv√©s",
        "L'envoi automatique des logs a √©t√© d√©sactiv√©."
      ).addFields([
        {
          name: "Guilde",
          value: guild.name,
          inline: true,
        },
      ]);

      await selectInteraction.update({
        embeds: [successEmbed],
        components: [],
      });
      return;
    }

    const selectedChannel = guild.channels.cache.get(selectedChannelId);

    if (!selectedChannel) {
      return replyEphemeral(selectInteraction, "Le salon s√©lectionn√© n'existe plus.");
    }

    // Sauvegarder dans la base de donn√©es
    await apiService.updateGuildLogChannel(guild.id, selectedChannelId);

    logger.info(
      `Log channel configured for guild ${guild.id}: ${selectedChannelId}`
    );

    const successEmbed = createSuccessEmbed(
      "‚úÖ Salon configur√© avec succ√®s",
      `Le salon ${selectedChannel} a √©t√© enregistr√© pour les logs automatiques.`
    ).addFields([
      {
        name: "Salon",
        value: `${selectedChannel}`,
        inline: true,
      },
      {
        name: "Guilde",
        value: guild.name,
        inline: true,
      },
    ]);

    await selectInteraction.update({
      embeds: [successEmbed],
      components: [],
    });
  } catch (error) {
    if (error instanceof Error && error.message.includes("time")) {
      // Timeout
      const timeoutEmbed = createWarningEmbed(
        "‚è∞ Temps √©coul√©",
        "La configuration a √©t√© annul√©e car aucune s√©lection n'a √©t√© faite dans le d√©lai imparti."
      );

      await interaction.editReply({
        embeds: [timeoutEmbed],
        components: [],
      });
    } else {
      logger.error("Error in channel selection:", { error });
      await interaction.editReply({
        content: "Une erreur est survenue lors de la s√©lection du salon.",
        embeds: [],
        components: [],
      });
    }
  }
}
