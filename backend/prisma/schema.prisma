// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Session {
  id        String   @id
  sid       String   @unique
  data      String
  expiresAt DateTime

  @@map("sessions")
}

model User {
  id            String      @id @default(cuid())
  discordId     String      @unique
  username      String // Nom d'utilisateur Discord
  discriminator String // Tag Discord (ex: "1234")
  globalName    String? // Nom global Discord (peut être null)
  avatar        String? // Hash de l'avatar
  characters    Character[]
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  @@map("users")
}

model Town {
  id             String          @id @default(cuid())
  name           String // Nom de la ville
  guild          Guild           @relation(fields: [guildId], references: [id], onDelete: Cascade)
  guildId        String          @unique @map("guild_id") // Chaque serveur a exactement une ville
  characters     Character[] // Relation avec les personnages de la ville
  chantiers      Chantier[]
  expeditions    Expedition[] // Relation avec les expéditions de la ville
  // Relations vers les stocks de ressources
  resourceStocks ResourceStock[]
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")

  @@map("towns")
}

model Guild {
  id             String   @id @default(cuid())
  discordGuildId String   @unique @map("discord_guild_id")
  name           String // Nom de la guilde
  memberCount    Int      @default(0) // Nombre de membres dans la guilde
  logChannelId   String? // ID du salon Discord pour les logs automatiques
  town           Town? // Relation 1:1 avec la ville
  roles          Role[] // Ajout de la relation avec les rôles
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@map("guilds")
}

model Character {
  id                String                @id @default(cuid())
  name              String // Nom du personnage (obligatoire)
  user              User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String                @map("user_id")
  town              Town                  @relation(fields: [townId], references: [id], onDelete: Cascade)
  townId            String                @map("town_id")
  characterRoles    CharacterRole[] // Relation avec les rôles
  expeditionMembers ExpeditionMember[] // Relation avec les membres d'expédition
  paTotal           Int                   @default(2) // 0-4
  lastPaUpdate      DateTime              @default(now()) @map("last_pa_update")
  hungerLevel       Int                   @default(4) @map("hunger_level") // 0: Mort, 1: Agonie, 2: Affamé, 3: Faim, 4: En bonne santé
  hp                Int                   @default(5) @map("hp") // Points de vie (0-5)
  pm                Int                   @default(5) @map("pm") // Points mentaux (0-5)
  isDead            Boolean               @default(false) @map("is_dead") // Indique si le personnage est mort
  canReroll         Boolean               @default(false) @map("can_reroll") // Autorise la création d'un nouveau personnage
  isActive          Boolean               @default(true) @map("is_active") // Personnage actif pour l'utilisateur dans cette ville
  divertCounter     Int                   @default(0) @map("divert_counter") // Compteur pour la capacité Divertir
  capabilities      CharacterCapability[] // Capacités connues par le personnage
  createdAt         DateTime              @default(now()) @map("created_at")
  updatedAt         DateTime              @updatedAt @map("updated_at")

  // SUPPRIMÉ : @@unique([userId, townId, isActive], name: "one_active_per_user_town") // Un seul personnage actif par user/town
  // REMPLACÉ PAR : Logique applicative dans les services pour garantir l'unicité
  @@index([userId])
  @@index([townId])
  @@index([userId, townId])
  @@index([userId, townId, isActive]) // Index pour les performances, mais pas de contrainte unique
}

enum ChantierStatus {
  PLAN
  IN_PROGRESS
  COMPLETED
}

enum CapabilityCategory {
  HARVEST
  SPECIAL
}

enum SeasonType {
  SUMMER
  WINTER
}

model Chantier {
  id        String         @id @default(cuid())
  name      String // Nom du chantier
  startDate DateTime?      @map("start_date") // Date du premier investissement de PA (null si pas commencé)
  cost      Int // Coût total en PA
  spendOnIt Int            @default(0) // Nombre de PA investis
  status    ChantierStatus @default(PLAN) // plan, in_progress, completed
  town      Town           @relation(fields: [townId], references: [id], onDelete: Cascade)
  townId    String         @map("town_id")
  createdBy String         @map("created_by") // ID Discord de l'utilisateur qui a créé le chantier
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @updatedAt @map("updated_at")

  @@unique([name, townId], name: "chantier_name_town_unique")
  @@map("chantiers")
}

model Capability {
  id          String                @id @default(cuid())
  name        String                @unique
  category    CapabilityCategory
  costPA      Int                   @map("cost_pa")
  description String?
  characters  CharacterCapability[]
  createdAt   DateTime              @default(now()) @map("created_at")
  updatedAt   DateTime              @updatedAt @map("updated_at")

  @@map("capabilities")
}

model CharacterCapability {
  characterId  String     @map("character_id")
  capabilityId String     @map("capability_id")
  character    Character  @relation(fields: [characterId], references: [id], onDelete: Cascade)
  capability   Capability @relation(fields: [capabilityId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  @@id([characterId, capabilityId])
  @@map("character_capabilities")
}

model Season {
  id        Int        @id @default(1) // Toujours un seul enregistrement
  name      SeasonType
  updatedAt DateTime   @updatedAt @map("updated_at")

  @@map("seasons")
}

model Role {
  id         String          @id @default(cuid())
  discordId  String // ID du rôle dans Discord
  name       String // Nom du rôle
  color      String? // Couleur du rôle (optionnel)
  guild      Guild           @relation(fields: [guildId], references: [id])
  guildId    String          @map("guild_id")
  characters CharacterRole[]
  createdAt  DateTime        @default(now()) @map("created_at")
  updatedAt  DateTime        @updatedAt @map("updated_at")

  @@unique([discordId, guildId], name: "role_guild_unique")
  @@map("roles")
}

model CharacterRole {
  id          String    @id @default(cuid())
  character   Character @relation(fields: [characterId], references: [id])
  characterId String    @map("character_id")
  role        Role      @relation(fields: [roleId], references: [id])
  roleId      String    @map("role_id")
  assignedAt  DateTime  @default(now()) @map("assigned_at")
  username    String    @map("username")
  roleName    String    @map("role_name")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  @@unique([characterId, roleId], name: "character_role_unique")
  @@map("character_roles")
}

enum ExpeditionStatus {
  PLANNING
  LOCKED
  DEPARTED
  RETURNED
}

enum LocationType {
  CITY
  EXPEDITION
}

model Expedition {
  id                      String                     @id @default(cuid())
  name                    String // Nom de l'expédition
  town                    Town                       @relation(fields: [townId], references: [id], onDelete: Cascade)
  townId                  String                     @map("town_id")
  status                  ExpeditionStatus           @default(PLANNING)
  duration                Int // Durée en jours
  returnAt                DateTime?                  @map("return_at") // Date de retour prévue (null si pas partie)
  createdBy               String                     @map("created_by") // ID Discord de l'utilisateur qui a créé l'expédition
  pendingEmergencyReturn  Boolean                    @default(false) @map("pending_emergency_return") // Vote de retour d'urgence en cours
  members                 ExpeditionMember[]
  emergencyVotes          ExpeditionEmergencyVote[] // Votes pour retour d'urgence
  // Relations vers les stocks de ressources
  resourceStocks          ResourceStock[]
  createdAt               DateTime                   @default(now()) @map("created_at")
  updatedAt               DateTime                   @updatedAt @map("updated_at")

  @@map("expeditions")
}

model ExpeditionMember {
  id           String     @id @default(cuid())
  expedition   Expedition @relation(fields: [expeditionId], references: [id], onDelete: Cascade)
  expeditionId String     @map("expedition_id")
  character    Character  @relation(fields: [characterId], references: [id], onDelete: Cascade)
  characterId  String     @map("character_id")
  joinedAt     DateTime   @default(now()) @map("joined_at")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  @@unique([expeditionId, characterId], name: "expedition_member_unique")
  @@map("expedition_members")
}

model ExpeditionEmergencyVote {
  id           String     @id @default(cuid())
  expedition   Expedition @relation(fields: [expeditionId], references: [id], onDelete: Cascade)
  expeditionId String     @map("expedition_id")
  userId       String     @map("user_id") // Discord User ID qui a voté
  votedAt      DateTime   @default(now()) @map("voted_at")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  @@unique([expeditionId, userId], name: "expedition_vote_unique")
  @@map("expedition_emergency_votes")
}

model ResourceType {
  id          Int             @id @default(autoincrement())
  name        String          @unique
  emoji       String
  category    String // 'base', 'transformé'
  description String?
  stocks      ResourceStock[] @relation("ResourceTypeToResourceStock")
  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @updatedAt @map("updated_at")

  @@map("resource_types")
}

model ResourceStock {
  id             Int          @id @default(autoincrement())
  locationType   LocationType
  locationId     String
  resourceTypeId Int
  quantity       Int          @default(0)

  // Relations vers les emplacements
  town         Town?       @relation(fields: [townId], references: [id], onDelete: Cascade)
  townId       String?     @map("town_id")
  expedition   Expedition? @relation(fields: [expeditionId], references: [id], onDelete: Cascade)
  expeditionId String?     @map("expedition_id")

  resourceType ResourceType @relation("ResourceTypeToResourceStock", fields: [resourceTypeId], references: [id], onDelete: Cascade)

  @@unique([locationType, locationId, resourceTypeId])
  @@index([locationType, locationId])
  @@map("resource_stocks")
}
